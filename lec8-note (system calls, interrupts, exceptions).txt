6.828 2014 Lecture 8: System calls, Interrupts, and Exceptions
==

* plan: user -> kernel transition 
  int instruction
  trap and return
  device interrupts

* three reasons to change from user to kernel
  systems calls
  program faults (div by zero, page fault)
  external device interrupts

* system calls, exceptions and interrupts (from xv6 book)
  system call: a user program can ask for an operating system service. 
  exception: an illegal program action that generates an interrupt. 
    examples of illegal programs actions include dividing by zero, 
    page fault, and so on. 
  interrupt: a signal generated by a hardware device, indicating that 
    it needs attention of the operating system. 
    for example, 
      a clock chip may generate an interrupt every 100 msec to allow 
      the kernel to implement time sharing
    another example, 
      when the disk has read a block, it generates an interrupt to alert 
      the operating system that the block is ready to be retrieved
      
* interrupts and exceptions in "80386 programmer's reference manual"
    see https://pdos.csail.mit.edu/6.828/2014/readings/i386/c09.htm
    
  the difference between interrupts and exceptions is that interrupts are
  used to handle asynchronous events external to the processor, but 
  exceptions handle conditions detected by the processor itself in 
  the course of executing instructions.

  there are two sources for external interrupts and two sources for exceptions:
    Interrupts
        Maskable interrupts, which are signalled via the INTR pin.
        Nonmaskable interrupts, which are signalled via the NMI (Non-Maskable Interrupt) pin. 
    Exceptions
        Processor detected. These are further classified as faults, traps, and aborts.
        Programmed. The instructions INTO, INT 3 (break point), INT n, and BOUND can 
        trigger exceptions. These instructions are often called "software interrupts", 
        but the processor handles them as exceptions. 
 
* A word on terminology: 
  although the official x86 term is interrupt, xv6 refers to all of these 
  as traps, largely because it was the term used by the PDP11/40 and 
  therefore is the conventional Unix term. 
  
  traps are caused by the current process running on a processor (e.g., 
  the process makes a system call and as a result generates a trap), 
  and interrupts are caused by devices and may not be related to the
  currently running process. 
  
  For example, a disk may generate an interrupt when it is done retrieving 
  a block for one process, but at the time of the interrupt some other
  process may be running.


* why do we need to take special care for user to kernel?
  security/isolation
  only kernel can touch devices, MMU, FS, other process' state, &c
  think of user program as a potential malicious adversary

* remember how x86 privilege levels work
    CPL in low 2 bits of CS
    CPL=0 -> can modify cr<n>, devices, can use any PTE
    CPL=3 -> can't modify cr<n>, or use devs, and PTE_U enforced
 
* what has to happen?
    save user state for future transparent resume
    set up for execution in kernel (stack, segments)
    choose a place to execute in kernel
    get at system call arguments
    do it all securely

* it is neat that interrupts, faults, system call use same mechanism
  the int instruction


The INT instruction
--

* The x86 CPU supports 256 interrupt vectors.
  Different hardware conditions produce interrupts through different vectors.
  The vector refers to an descriptor in the IDT.
  The CPU's IDTR register holds the (virtual) base address of the IDT.
  Each descriptor contains a segment selector, an offset in that segment, and a DPL.

* The INT instruction takes the following steps on a system call

  (these will be similar to all interrupts and faults, though there are
   slight differences):

  1. decide the vector number, in this case it's the 0x40 in int 0x40

  2. fetch the interrupt descriptor for vector 0x40 from the IDT.

     the CPU finds it by taking the 0x40'th 8-byte entry starting at the physical
     address that the IDTR CPU register points to.

  3. check that CPL <= DPL in the descriptor (but only if INT instruction).

  4. save ESP and SS in a CPU-internal register (but only if target segment selector's PL < CPL).

  5. load SS and ESP from TSS ("")

  6. push user SS ("")
 
  7. push user ESP ("")
  
  8. push user EFLAGS

  9. push user CS

  10. push user EIP

  11. clear some EFLAGS bits

  12. set CS and EIP from IDT descriptor's segment selector and offset


Device Interrupts
--

* Like system calls, except:
  devices generate them at any time
  there are no arguments in CPU registers
  nothing to return to
  usually can't ignore them (unless set ignore flags in EFLAGS)

* Implementation
  There is hardware on the motherboard to signal the CPU when a device needs attention
    (e.g. the user has typed a character on the keyboard).
  There's usually a separate vector for each device.
  
* Let's look at the timer interrupt
  the timer hardware generates an interrupt 100 times per second
  allows the kernel can track the passage of time
  allows the kernel can time-slice among multiple running processes.
  The timer interrupts through vector 32.

* The interrupt will have pushed different numbers of words on the stack depending 
  on whether the CPU was in user-space or the kernel;
  how does iret know how many words to pop? 
    the lowest two bits of %cs saved by int instruction

* What prevents lots of interrupts from coming in all at once and overflowing the 
  kernel stack?
  interrupt gates clear IF, so that the interrupted processor doesn't receive 
  interrupts while it is handling the current interrupt
  
* trap() (xv6), when it's called for a time interrupt, does just two things
  * increment the ticks variable, and call wakeup().
  * At the end of trap, xv6 calls yield.
    as we will see, may cause the interrupt to return in a different process!

JOS
---

* JOS also has a different kernel architecture than xv6:
  only one kernel stack (per processor)

* The kernel is not re-entrant (cannot be interrupted),
  so all IDT entries are interrupt gates in JOS.
